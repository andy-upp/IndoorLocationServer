// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: WifiMessage.proto

#ifndef PROTOBUF_WifiMessage_2eproto__INCLUDED
#define PROTOBUF_WifiMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace vrmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_WifiMessage_2eproto();
void protobuf_AssignDesc_WifiMessage_2eproto();
void protobuf_ShutdownFile_WifiMessage_2eproto();

class ActorMoving;
class CreateRole;
class LoginRequest;
class LoginResponse;
class QueryPostionRequest;
class QueryPostionResponse;
class AddWifiSignalRequest;
class Vector3;
class Quaternion;
class Role;
class RoleGroup;
class WifiSignal;

// ===================================================================

class ActorMoving : public ::google::protobuf::Message {
 public:
  ActorMoving();
  virtual ~ActorMoving();

  ActorMoving(const ActorMoving& from);

  inline ActorMoving& operator=(const ActorMoving& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorMoving& default_instance();

  void Swap(ActorMoving* other);

  // implements Message ----------------------------------------------

  ActorMoving* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorMoving& from);
  void MergeFrom(const ActorMoving& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional .vrmsg.Vector3 v_end = 2;
  inline bool has_v_end() const;
  inline void clear_v_end();
  static const int kVEndFieldNumber = 2;
  inline const ::vrmsg::Vector3& v_end() const;
  inline ::vrmsg::Vector3* mutable_v_end();
  inline ::vrmsg::Vector3* release_v_end();
  inline void set_allocated_v_end(::vrmsg::Vector3* v_end);

  // optional double speed = 3;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 3;
  inline double speed() const;
  inline void set_speed(double value);

  // @@protoc_insertion_point(class_scope:vrmsg.ActorMoving)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_v_end();
  inline void clear_has_v_end();
  inline void set_has_speed();
  inline void clear_has_speed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::vrmsg::Vector3* v_end_;
  double speed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_WifiMessage_2eproto();
  friend void protobuf_AssignDesc_WifiMessage_2eproto();
  friend void protobuf_ShutdownFile_WifiMessage_2eproto();

  void InitAsDefaultInstance();
  static ActorMoving* default_instance_;
};
// -------------------------------------------------------------------

class CreateRole : public ::google::protobuf::Message {
 public:
  CreateRole();
  virtual ~CreateRole();

  CreateRole(const CreateRole& from);

  inline CreateRole& operator=(const CreateRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRole& default_instance();

  void Swap(CreateRole* other);

  // implements Message ----------------------------------------------

  CreateRole* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRole& from);
  void MergeFrom(const CreateRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vrmsg.Role role = 1;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline const ::vrmsg::Role& role() const;
  inline ::vrmsg::Role* mutable_role();
  inline ::vrmsg::Role* release_role();
  inline void set_allocated_role(::vrmsg::Role* role);

  // @@protoc_insertion_point(class_scope:vrmsg.CreateRole)
 private:
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::vrmsg::Role* role_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_WifiMessage_2eproto();
  friend void protobuf_AssignDesc_WifiMessage_2eproto();
  friend void protobuf_ShutdownFile_WifiMessage_2eproto();

  void InitAsDefaultInstance();
  static CreateRole* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const void* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required bytes password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const void* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:vrmsg.LoginRequest)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_WifiMessage_2eproto();
  friend void protobuf_AssignDesc_WifiMessage_2eproto();
  friend void protobuf_ShutdownFile_WifiMessage_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional bytes error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline const ::std::string& error_code() const;
  inline void set_error_code(const ::std::string& value);
  inline void set_error_code(const char* value);
  inline void set_error_code(const void* value, size_t size);
  inline ::std::string* mutable_error_code();
  inline ::std::string* release_error_code();
  inline void set_allocated_error_code(::std::string* error_code);

  // optional bytes error_description = 3;
  inline bool has_error_description() const;
  inline void clear_error_description();
  static const int kErrorDescriptionFieldNumber = 3;
  inline const ::std::string& error_description() const;
  inline void set_error_description(const ::std::string& value);
  inline void set_error_description(const char* value);
  inline void set_error_description(const void* value, size_t size);
  inline ::std::string* mutable_error_description();
  inline ::std::string* release_error_description();
  inline void set_allocated_error_description(::std::string* error_description);

  // optional string login_state = 4;
  inline bool has_login_state() const;
  inline void clear_login_state();
  static const int kLoginStateFieldNumber = 4;
  inline const ::std::string& login_state() const;
  inline void set_login_state(const ::std::string& value);
  inline void set_login_state(const char* value);
  inline void set_login_state(const char* value, size_t size);
  inline ::std::string* mutable_login_state();
  inline ::std::string* release_login_state();
  inline void set_allocated_login_state(::std::string* login_state);

  // optional string login_time = 5;
  inline bool has_login_time() const;
  inline void clear_login_time();
  static const int kLoginTimeFieldNumber = 5;
  inline const ::std::string& login_time() const;
  inline void set_login_time(const ::std::string& value);
  inline void set_login_time(const char* value);
  inline void set_login_time(const char* value, size_t size);
  inline ::std::string* mutable_login_time();
  inline ::std::string* release_login_time();
  inline void set_allocated_login_time(::std::string* login_time);

  // optional string licence = 6;
  inline bool has_licence() const;
  inline void clear_licence();
  static const int kLicenceFieldNumber = 6;
  inline const ::std::string& licence() const;
  inline void set_licence(const ::std::string& value);
  inline void set_licence(const char* value);
  inline void set_licence(const char* value, size_t size);
  inline ::std::string* mutable_licence();
  inline ::std::string* release_licence();
  inline void set_allocated_licence(::std::string* licence);

  // @@protoc_insertion_point(class_scope:vrmsg.LoginResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_error_description();
  inline void clear_has_error_description();
  inline void set_has_login_state();
  inline void clear_has_login_state();
  inline void set_has_login_time();
  inline void clear_has_login_time();
  inline void set_has_licence();
  inline void clear_has_licence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_code_;
  ::std::string* error_description_;
  ::std::string* login_state_;
  ::std::string* login_time_;
  ::std::string* licence_;
  bool result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_WifiMessage_2eproto();
  friend void protobuf_AssignDesc_WifiMessage_2eproto();
  friend void protobuf_ShutdownFile_WifiMessage_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class QueryPostionRequest : public ::google::protobuf::Message {
 public:
  QueryPostionRequest();
  virtual ~QueryPostionRequest();

  QueryPostionRequest(const QueryPostionRequest& from);

  inline QueryPostionRequest& operator=(const QueryPostionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryPostionRequest& default_instance();

  void Swap(QueryPostionRequest* other);

  // implements Message ----------------------------------------------

  QueryPostionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryPostionRequest& from);
  void MergeFrom(const QueryPostionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vrmsg.WifiSignal signals = 1;
  inline int signals_size() const;
  inline void clear_signals();
  static const int kSignalsFieldNumber = 1;
  inline const ::vrmsg::WifiSignal& signals(int index) const;
  inline ::vrmsg::WifiSignal* mutable_signals(int index);
  inline ::vrmsg::WifiSignal* add_signals();
  inline const ::google::protobuf::RepeatedPtrField< ::vrmsg::WifiSignal >&
      signals() const;
  inline ::google::protobuf::RepeatedPtrField< ::vrmsg::WifiSignal >*
      mutable_signals();

  // @@protoc_insertion_point(class_scope:vrmsg.QueryPostionRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::vrmsg::WifiSignal > signals_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_WifiMessage_2eproto();
  friend void protobuf_AssignDesc_WifiMessage_2eproto();
  friend void protobuf_ShutdownFile_WifiMessage_2eproto();

  void InitAsDefaultInstance();
  static QueryPostionRequest* default_instance_;
};
// -------------------------------------------------------------------

class QueryPostionResponse : public ::google::protobuf::Message {
 public:
  QueryPostionResponse();
  virtual ~QueryPostionResponse();

  QueryPostionResponse(const QueryPostionResponse& from);

  inline QueryPostionResponse& operator=(const QueryPostionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryPostionResponse& default_instance();

  void Swap(QueryPostionResponse* other);

  // implements Message ----------------------------------------------

  QueryPostionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryPostionResponse& from);
  void MergeFrom(const QueryPostionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vrmsg.Vector3 postions = 1;
  inline int postions_size() const;
  inline void clear_postions();
  static const int kPostionsFieldNumber = 1;
  inline const ::vrmsg::Vector3& postions(int index) const;
  inline ::vrmsg::Vector3* mutable_postions(int index);
  inline ::vrmsg::Vector3* add_postions();
  inline const ::google::protobuf::RepeatedPtrField< ::vrmsg::Vector3 >&
      postions() const;
  inline ::google::protobuf::RepeatedPtrField< ::vrmsg::Vector3 >*
      mutable_postions();

  // @@protoc_insertion_point(class_scope:vrmsg.QueryPostionResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::vrmsg::Vector3 > postions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_WifiMessage_2eproto();
  friend void protobuf_AssignDesc_WifiMessage_2eproto();
  friend void protobuf_ShutdownFile_WifiMessage_2eproto();

  void InitAsDefaultInstance();
  static QueryPostionResponse* default_instance_;
};
// -------------------------------------------------------------------

class AddWifiSignalRequest : public ::google::protobuf::Message {
 public:
  AddWifiSignalRequest();
  virtual ~AddWifiSignalRequest();

  AddWifiSignalRequest(const AddWifiSignalRequest& from);

  inline AddWifiSignalRequest& operator=(const AddWifiSignalRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddWifiSignalRequest& default_instance();

  void Swap(AddWifiSignalRequest* other);

  // implements Message ----------------------------------------------

  AddWifiSignalRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddWifiSignalRequest& from);
  void MergeFrom(const AddWifiSignalRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vrmsg.WifiSignal signals = 1;
  inline int signals_size() const;
  inline void clear_signals();
  static const int kSignalsFieldNumber = 1;
  inline const ::vrmsg::WifiSignal& signals(int index) const;
  inline ::vrmsg::WifiSignal* mutable_signals(int index);
  inline ::vrmsg::WifiSignal* add_signals();
  inline const ::google::protobuf::RepeatedPtrField< ::vrmsg::WifiSignal >&
      signals() const;
  inline ::google::protobuf::RepeatedPtrField< ::vrmsg::WifiSignal >*
      mutable_signals();

  // @@protoc_insertion_point(class_scope:vrmsg.AddWifiSignalRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::vrmsg::WifiSignal > signals_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_WifiMessage_2eproto();
  friend void protobuf_AssignDesc_WifiMessage_2eproto();
  friend void protobuf_ShutdownFile_WifiMessage_2eproto();

  void InitAsDefaultInstance();
  static AddWifiSignalRequest* default_instance_;
};
// -------------------------------------------------------------------

class Vector3 : public ::google::protobuf::Message {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  void Swap(Vector3* other);

  // implements Message ----------------------------------------------

  Vector3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:vrmsg.Vector3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_WifiMessage_2eproto();
  friend void protobuf_AssignDesc_WifiMessage_2eproto();
  friend void protobuf_ShutdownFile_WifiMessage_2eproto();

  void InitAsDefaultInstance();
  static Vector3* default_instance_;
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion& default_instance();

  void Swap(Quaternion* other);

  // implements Message ----------------------------------------------

  Quaternion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // required double w = 4;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline double w() const;
  inline void set_w(double value);

  // @@protoc_insertion_point(class_scope:vrmsg.Quaternion)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double z_;
  double w_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_WifiMessage_2eproto();
  friend void protobuf_AssignDesc_WifiMessage_2eproto();
  friend void protobuf_ShutdownFile_WifiMessage_2eproto();

  void InitAsDefaultInstance();
  static Quaternion* default_instance_;
};
// -------------------------------------------------------------------

class Role : public ::google::protobuf::Message {
 public:
  Role();
  virtual ~Role();

  Role(const Role& from);

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Role& default_instance();

  void Swap(Role* other);

  // implements Message ----------------------------------------------

  Role* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Role& from);
  void MergeFrom(const Role& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 10;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 10;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes perfab_name = 2;
  inline bool has_perfab_name() const;
  inline void clear_perfab_name();
  static const int kPerfabNameFieldNumber = 2;
  inline const ::std::string& perfab_name() const;
  inline void set_perfab_name(const ::std::string& value);
  inline void set_perfab_name(const char* value);
  inline void set_perfab_name(const void* value, size_t size);
  inline ::std::string* mutable_perfab_name();
  inline ::std::string* release_perfab_name();
  inline void set_allocated_perfab_name(::std::string* perfab_name);

  // optional .vrmsg.Vector3 position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::vrmsg::Vector3& position() const;
  inline ::vrmsg::Vector3* mutable_position();
  inline ::vrmsg::Vector3* release_position();
  inline void set_allocated_position(::vrmsg::Vector3* position);

  // optional .vrmsg.Vector3 rotation = 4;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 4;
  inline const ::vrmsg::Vector3& rotation() const;
  inline ::vrmsg::Vector3* mutable_rotation();
  inline ::vrmsg::Vector3* release_rotation();
  inline void set_allocated_rotation(::vrmsg::Vector3* rotation);

  // optional .vrmsg.Vector3 scale = 5;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 5;
  inline const ::vrmsg::Vector3& scale() const;
  inline ::vrmsg::Vector3* mutable_scale();
  inline ::vrmsg::Vector3* release_scale();
  inline void set_allocated_scale(::vrmsg::Vector3* scale);

  // optional string groupID = 6;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 6;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const char* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // optional bytes tag_name = 7;
  inline bool has_tag_name() const;
  inline void clear_tag_name();
  static const int kTagNameFieldNumber = 7;
  inline const ::std::string& tag_name() const;
  inline void set_tag_name(const ::std::string& value);
  inline void set_tag_name(const char* value);
  inline void set_tag_name(const void* value, size_t size);
  inline ::std::string* mutable_tag_name();
  inline ::std::string* release_tag_name();
  inline void set_allocated_tag_name(::std::string* tag_name);

  // optional int32 layer = 8;
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 8;
  inline ::google::protobuf::int32 layer() const;
  inline void set_layer(::google::protobuf::int32 value);

  // optional bool isNPC = 9;
  inline bool has_isnpc() const;
  inline void clear_isnpc();
  static const int kIsNPCFieldNumber = 9;
  inline bool isnpc() const;
  inline void set_isnpc(bool value);

  // @@protoc_insertion_point(class_scope:vrmsg.Role)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_perfab_name();
  inline void clear_has_perfab_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_tag_name();
  inline void clear_has_tag_name();
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_isnpc();
  inline void clear_has_isnpc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::std::string* perfab_name_;
  ::vrmsg::Vector3* position_;
  ::vrmsg::Vector3* rotation_;
  ::vrmsg::Vector3* scale_;
  ::std::string* groupid_;
  ::std::string* tag_name_;
  ::google::protobuf::int32 layer_;
  bool isnpc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_WifiMessage_2eproto();
  friend void protobuf_AssignDesc_WifiMessage_2eproto();
  friend void protobuf_ShutdownFile_WifiMessage_2eproto();

  void InitAsDefaultInstance();
  static Role* default_instance_;
};
// -------------------------------------------------------------------

class RoleGroup : public ::google::protobuf::Message {
 public:
  RoleGroup();
  virtual ~RoleGroup();

  RoleGroup(const RoleGroup& from);

  inline RoleGroup& operator=(const RoleGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleGroup& default_instance();

  void Swap(RoleGroup* other);

  // implements Message ----------------------------------------------

  RoleGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoleGroup& from);
  void MergeFrom(const RoleGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string creater_id = 3;
  inline bool has_creater_id() const;
  inline void clear_creater_id();
  static const int kCreaterIdFieldNumber = 3;
  inline const ::std::string& creater_id() const;
  inline void set_creater_id(const ::std::string& value);
  inline void set_creater_id(const char* value);
  inline void set_creater_id(const char* value, size_t size);
  inline ::std::string* mutable_creater_id();
  inline ::std::string* release_creater_id();
  inline void set_allocated_creater_id(::std::string* creater_id);

  // optional string create_time = 4;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 4;
  inline const ::std::string& create_time() const;
  inline void set_create_time(const ::std::string& value);
  inline void set_create_time(const char* value);
  inline void set_create_time(const char* value, size_t size);
  inline ::std::string* mutable_create_time();
  inline ::std::string* release_create_time();
  inline void set_allocated_create_time(::std::string* create_time);

  // optional bytes description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const void* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string color = 6;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 6;
  inline const ::std::string& color() const;
  inline void set_color(const ::std::string& value);
  inline void set_color(const char* value);
  inline void set_color(const char* value, size_t size);
  inline ::std::string* mutable_color();
  inline ::std::string* release_color();
  inline void set_allocated_color(::std::string* color);

  // @@protoc_insertion_point(class_scope:vrmsg.RoleGroup)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_creater_id();
  inline void clear_has_creater_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_color();
  inline void clear_has_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::std::string* creater_id_;
  ::std::string* create_time_;
  ::std::string* description_;
  ::std::string* color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_WifiMessage_2eproto();
  friend void protobuf_AssignDesc_WifiMessage_2eproto();
  friend void protobuf_ShutdownFile_WifiMessage_2eproto();

  void InitAsDefaultInstance();
  static RoleGroup* default_instance_;
};
// -------------------------------------------------------------------

class WifiSignal : public ::google::protobuf::Message {
 public:
  WifiSignal();
  virtual ~WifiSignal();

  WifiSignal(const WifiSignal& from);

  inline WifiSignal& operator=(const WifiSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WifiSignal& default_instance();

  void Swap(WifiSignal* other);

  // implements Message ----------------------------------------------

  WifiSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WifiSignal& from);
  void MergeFrom(const WifiSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 intensity = 2;
  inline bool has_intensity() const;
  inline void clear_intensity();
  static const int kIntensityFieldNumber = 2;
  inline ::google::protobuf::int32 intensity() const;
  inline void set_intensity(::google::protobuf::int32 value);

  // optional .vrmsg.Vector3 myPos = 3;
  inline bool has_mypos() const;
  inline void clear_mypos();
  static const int kMyPosFieldNumber = 3;
  inline const ::vrmsg::Vector3& mypos() const;
  inline ::vrmsg::Vector3* mutable_mypos();
  inline ::vrmsg::Vector3* release_mypos();
  inline void set_allocated_mypos(::vrmsg::Vector3* mypos);

  // optional string device = 4;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 4;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string nowtime = 6;
  inline bool has_nowtime() const;
  inline void clear_nowtime();
  static const int kNowtimeFieldNumber = 6;
  inline const ::std::string& nowtime() const;
  inline void set_nowtime(const ::std::string& value);
  inline void set_nowtime(const char* value);
  inline void set_nowtime(const char* value, size_t size);
  inline ::std::string* mutable_nowtime();
  inline ::std::string* release_nowtime();
  inline void set_allocated_nowtime(::std::string* nowtime);

  // @@protoc_insertion_point(class_scope:vrmsg.WifiSignal)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_intensity();
  inline void clear_has_intensity();
  inline void set_has_mypos();
  inline void clear_has_mypos();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_nowtime();
  inline void clear_has_nowtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::vrmsg::Vector3* mypos_;
  ::std::string* device_;
  ::std::string* name_;
  ::std::string* nowtime_;
  ::google::protobuf::int32 intensity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_WifiMessage_2eproto();
  friend void protobuf_AssignDesc_WifiMessage_2eproto();
  friend void protobuf_ShutdownFile_WifiMessage_2eproto();

  void InitAsDefaultInstance();
  static WifiSignal* default_instance_;
};
// ===================================================================


// ===================================================================

// ActorMoving

// optional string id = 1;
inline bool ActorMoving::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorMoving::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorMoving::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorMoving::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ActorMoving::id() const {
  return *id_;
}
inline void ActorMoving::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ActorMoving::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ActorMoving::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActorMoving::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ActorMoving::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActorMoving::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .vrmsg.Vector3 v_end = 2;
inline bool ActorMoving::has_v_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActorMoving::set_has_v_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActorMoving::clear_has_v_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActorMoving::clear_v_end() {
  if (v_end_ != NULL) v_end_->::vrmsg::Vector3::Clear();
  clear_has_v_end();
}
inline const ::vrmsg::Vector3& ActorMoving::v_end() const {
  return v_end_ != NULL ? *v_end_ : *default_instance_->v_end_;
}
inline ::vrmsg::Vector3* ActorMoving::mutable_v_end() {
  set_has_v_end();
  if (v_end_ == NULL) v_end_ = new ::vrmsg::Vector3;
  return v_end_;
}
inline ::vrmsg::Vector3* ActorMoving::release_v_end() {
  clear_has_v_end();
  ::vrmsg::Vector3* temp = v_end_;
  v_end_ = NULL;
  return temp;
}
inline void ActorMoving::set_allocated_v_end(::vrmsg::Vector3* v_end) {
  delete v_end_;
  v_end_ = v_end;
  if (v_end) {
    set_has_v_end();
  } else {
    clear_has_v_end();
  }
}

// optional double speed = 3;
inline bool ActorMoving::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActorMoving::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActorMoving::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActorMoving::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double ActorMoving::speed() const {
  return speed_;
}
inline void ActorMoving::set_speed(double value) {
  set_has_speed();
  speed_ = value;
}

// -------------------------------------------------------------------

// CreateRole

// optional .vrmsg.Role role = 1;
inline bool CreateRole::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRole::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRole::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRole::clear_role() {
  if (role_ != NULL) role_->::vrmsg::Role::Clear();
  clear_has_role();
}
inline const ::vrmsg::Role& CreateRole::role() const {
  return role_ != NULL ? *role_ : *default_instance_->role_;
}
inline ::vrmsg::Role* CreateRole::mutable_role() {
  set_has_role();
  if (role_ == NULL) role_ = new ::vrmsg::Role;
  return role_;
}
inline ::vrmsg::Role* CreateRole::release_role() {
  clear_has_role();
  ::vrmsg::Role* temp = role_;
  role_ = NULL;
  return temp;
}
inline void CreateRole::set_allocated_role(::vrmsg::Role* role) {
  delete role_;
  role_ = role;
  if (role) {
    set_has_role();
  } else {
    clear_has_role();
  }
}

// -------------------------------------------------------------------

// LoginRequest

// required bytes user_name = 1;
inline bool LoginRequest::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& LoginRequest::user_name() const {
  return *user_name_;
}
inline void LoginRequest::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginRequest::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginRequest::set_user_name(const void* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* LoginRequest::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes password = 2;
inline bool LoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginRequest::password() const {
  return *password_;
}
inline void LoginRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const void* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginResponse

// required bool result = 1;
inline bool LoginResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool LoginResponse::result() const {
  return result_;
}
inline void LoginResponse::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional bytes error_code = 2;
inline bool LoginResponse::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_error_code() {
  if (error_code_ != &::google::protobuf::internal::kEmptyString) {
    error_code_->clear();
  }
  clear_has_error_code();
}
inline const ::std::string& LoginResponse::error_code() const {
  return *error_code_;
}
inline void LoginResponse::set_error_code(const ::std::string& value) {
  set_has_error_code();
  if (error_code_ == &::google::protobuf::internal::kEmptyString) {
    error_code_ = new ::std::string;
  }
  error_code_->assign(value);
}
inline void LoginResponse::set_error_code(const char* value) {
  set_has_error_code();
  if (error_code_ == &::google::protobuf::internal::kEmptyString) {
    error_code_ = new ::std::string;
  }
  error_code_->assign(value);
}
inline void LoginResponse::set_error_code(const void* value, size_t size) {
  set_has_error_code();
  if (error_code_ == &::google::protobuf::internal::kEmptyString) {
    error_code_ = new ::std::string;
  }
  error_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_error_code() {
  set_has_error_code();
  if (error_code_ == &::google::protobuf::internal::kEmptyString) {
    error_code_ = new ::std::string;
  }
  return error_code_;
}
inline ::std::string* LoginResponse::release_error_code() {
  clear_has_error_code();
  if (error_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_code_;
    error_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_error_code(::std::string* error_code) {
  if (error_code_ != &::google::protobuf::internal::kEmptyString) {
    delete error_code_;
  }
  if (error_code) {
    set_has_error_code();
    error_code_ = error_code;
  } else {
    clear_has_error_code();
    error_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes error_description = 3;
inline bool LoginResponse::has_error_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_error_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_error_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_error_description() {
  if (error_description_ != &::google::protobuf::internal::kEmptyString) {
    error_description_->clear();
  }
  clear_has_error_description();
}
inline const ::std::string& LoginResponse::error_description() const {
  return *error_description_;
}
inline void LoginResponse::set_error_description(const ::std::string& value) {
  set_has_error_description();
  if (error_description_ == &::google::protobuf::internal::kEmptyString) {
    error_description_ = new ::std::string;
  }
  error_description_->assign(value);
}
inline void LoginResponse::set_error_description(const char* value) {
  set_has_error_description();
  if (error_description_ == &::google::protobuf::internal::kEmptyString) {
    error_description_ = new ::std::string;
  }
  error_description_->assign(value);
}
inline void LoginResponse::set_error_description(const void* value, size_t size) {
  set_has_error_description();
  if (error_description_ == &::google::protobuf::internal::kEmptyString) {
    error_description_ = new ::std::string;
  }
  error_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_error_description() {
  set_has_error_description();
  if (error_description_ == &::google::protobuf::internal::kEmptyString) {
    error_description_ = new ::std::string;
  }
  return error_description_;
}
inline ::std::string* LoginResponse::release_error_description() {
  clear_has_error_description();
  if (error_description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_description_;
    error_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_error_description(::std::string* error_description) {
  if (error_description_ != &::google::protobuf::internal::kEmptyString) {
    delete error_description_;
  }
  if (error_description) {
    set_has_error_description();
    error_description_ = error_description;
  } else {
    clear_has_error_description();
    error_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string login_state = 4;
inline bool LoginResponse::has_login_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResponse::set_has_login_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResponse::clear_has_login_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResponse::clear_login_state() {
  if (login_state_ != &::google::protobuf::internal::kEmptyString) {
    login_state_->clear();
  }
  clear_has_login_state();
}
inline const ::std::string& LoginResponse::login_state() const {
  return *login_state_;
}
inline void LoginResponse::set_login_state(const ::std::string& value) {
  set_has_login_state();
  if (login_state_ == &::google::protobuf::internal::kEmptyString) {
    login_state_ = new ::std::string;
  }
  login_state_->assign(value);
}
inline void LoginResponse::set_login_state(const char* value) {
  set_has_login_state();
  if (login_state_ == &::google::protobuf::internal::kEmptyString) {
    login_state_ = new ::std::string;
  }
  login_state_->assign(value);
}
inline void LoginResponse::set_login_state(const char* value, size_t size) {
  set_has_login_state();
  if (login_state_ == &::google::protobuf::internal::kEmptyString) {
    login_state_ = new ::std::string;
  }
  login_state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_login_state() {
  set_has_login_state();
  if (login_state_ == &::google::protobuf::internal::kEmptyString) {
    login_state_ = new ::std::string;
  }
  return login_state_;
}
inline ::std::string* LoginResponse::release_login_state() {
  clear_has_login_state();
  if (login_state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_state_;
    login_state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_login_state(::std::string* login_state) {
  if (login_state_ != &::google::protobuf::internal::kEmptyString) {
    delete login_state_;
  }
  if (login_state) {
    set_has_login_state();
    login_state_ = login_state;
  } else {
    clear_has_login_state();
    login_state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string login_time = 5;
inline bool LoginResponse::has_login_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResponse::set_has_login_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResponse::clear_has_login_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResponse::clear_login_time() {
  if (login_time_ != &::google::protobuf::internal::kEmptyString) {
    login_time_->clear();
  }
  clear_has_login_time();
}
inline const ::std::string& LoginResponse::login_time() const {
  return *login_time_;
}
inline void LoginResponse::set_login_time(const ::std::string& value) {
  set_has_login_time();
  if (login_time_ == &::google::protobuf::internal::kEmptyString) {
    login_time_ = new ::std::string;
  }
  login_time_->assign(value);
}
inline void LoginResponse::set_login_time(const char* value) {
  set_has_login_time();
  if (login_time_ == &::google::protobuf::internal::kEmptyString) {
    login_time_ = new ::std::string;
  }
  login_time_->assign(value);
}
inline void LoginResponse::set_login_time(const char* value, size_t size) {
  set_has_login_time();
  if (login_time_ == &::google::protobuf::internal::kEmptyString) {
    login_time_ = new ::std::string;
  }
  login_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_login_time() {
  set_has_login_time();
  if (login_time_ == &::google::protobuf::internal::kEmptyString) {
    login_time_ = new ::std::string;
  }
  return login_time_;
}
inline ::std::string* LoginResponse::release_login_time() {
  clear_has_login_time();
  if (login_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_time_;
    login_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_login_time(::std::string* login_time) {
  if (login_time_ != &::google::protobuf::internal::kEmptyString) {
    delete login_time_;
  }
  if (login_time) {
    set_has_login_time();
    login_time_ = login_time;
  } else {
    clear_has_login_time();
    login_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string licence = 6;
inline bool LoginResponse::has_licence() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginResponse::set_has_licence() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginResponse::clear_has_licence() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginResponse::clear_licence() {
  if (licence_ != &::google::protobuf::internal::kEmptyString) {
    licence_->clear();
  }
  clear_has_licence();
}
inline const ::std::string& LoginResponse::licence() const {
  return *licence_;
}
inline void LoginResponse::set_licence(const ::std::string& value) {
  set_has_licence();
  if (licence_ == &::google::protobuf::internal::kEmptyString) {
    licence_ = new ::std::string;
  }
  licence_->assign(value);
}
inline void LoginResponse::set_licence(const char* value) {
  set_has_licence();
  if (licence_ == &::google::protobuf::internal::kEmptyString) {
    licence_ = new ::std::string;
  }
  licence_->assign(value);
}
inline void LoginResponse::set_licence(const char* value, size_t size) {
  set_has_licence();
  if (licence_ == &::google::protobuf::internal::kEmptyString) {
    licence_ = new ::std::string;
  }
  licence_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_licence() {
  set_has_licence();
  if (licence_ == &::google::protobuf::internal::kEmptyString) {
    licence_ = new ::std::string;
  }
  return licence_;
}
inline ::std::string* LoginResponse::release_licence() {
  clear_has_licence();
  if (licence_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = licence_;
    licence_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_licence(::std::string* licence) {
  if (licence_ != &::google::protobuf::internal::kEmptyString) {
    delete licence_;
  }
  if (licence) {
    set_has_licence();
    licence_ = licence;
  } else {
    clear_has_licence();
    licence_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryPostionRequest

// repeated .vrmsg.WifiSignal signals = 1;
inline int QueryPostionRequest::signals_size() const {
  return signals_.size();
}
inline void QueryPostionRequest::clear_signals() {
  signals_.Clear();
}
inline const ::vrmsg::WifiSignal& QueryPostionRequest::signals(int index) const {
  return signals_.Get(index);
}
inline ::vrmsg::WifiSignal* QueryPostionRequest::mutable_signals(int index) {
  return signals_.Mutable(index);
}
inline ::vrmsg::WifiSignal* QueryPostionRequest::add_signals() {
  return signals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vrmsg::WifiSignal >&
QueryPostionRequest::signals() const {
  return signals_;
}
inline ::google::protobuf::RepeatedPtrField< ::vrmsg::WifiSignal >*
QueryPostionRequest::mutable_signals() {
  return &signals_;
}

// -------------------------------------------------------------------

// QueryPostionResponse

// repeated .vrmsg.Vector3 postions = 1;
inline int QueryPostionResponse::postions_size() const {
  return postions_.size();
}
inline void QueryPostionResponse::clear_postions() {
  postions_.Clear();
}
inline const ::vrmsg::Vector3& QueryPostionResponse::postions(int index) const {
  return postions_.Get(index);
}
inline ::vrmsg::Vector3* QueryPostionResponse::mutable_postions(int index) {
  return postions_.Mutable(index);
}
inline ::vrmsg::Vector3* QueryPostionResponse::add_postions() {
  return postions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vrmsg::Vector3 >&
QueryPostionResponse::postions() const {
  return postions_;
}
inline ::google::protobuf::RepeatedPtrField< ::vrmsg::Vector3 >*
QueryPostionResponse::mutable_postions() {
  return &postions_;
}

// -------------------------------------------------------------------

// AddWifiSignalRequest

// repeated .vrmsg.WifiSignal signals = 1;
inline int AddWifiSignalRequest::signals_size() const {
  return signals_.size();
}
inline void AddWifiSignalRequest::clear_signals() {
  signals_.Clear();
}
inline const ::vrmsg::WifiSignal& AddWifiSignalRequest::signals(int index) const {
  return signals_.Get(index);
}
inline ::vrmsg::WifiSignal* AddWifiSignalRequest::mutable_signals(int index) {
  return signals_.Mutable(index);
}
inline ::vrmsg::WifiSignal* AddWifiSignalRequest::add_signals() {
  return signals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vrmsg::WifiSignal >&
AddWifiSignalRequest::signals() const {
  return signals_;
}
inline ::google::protobuf::RepeatedPtrField< ::vrmsg::WifiSignal >*
AddWifiSignalRequest::mutable_signals() {
  return &signals_;
}

// -------------------------------------------------------------------

// Vector3

// required double x = 1;
inline bool Vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vector3::x() const {
  return x_;
}
inline void Vector3::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool Vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vector3::y() const {
  return y_;
}
inline void Vector3::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 3;
inline bool Vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vector3::z() const {
  return z_;
}
inline void Vector3::set_z(double value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// Quaternion

// required double x = 1;
inline bool Quaternion::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Quaternion::x() const {
  return x_;
}
inline void Quaternion::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool Quaternion::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Quaternion::y() const {
  return y_;
}
inline void Quaternion::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 3;
inline bool Quaternion::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Quaternion::z() const {
  return z_;
}
inline void Quaternion::set_z(double value) {
  set_has_z();
  z_ = value;
}

// required double w = 4;
inline bool Quaternion::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Quaternion::w() const {
  return w_;
}
inline void Quaternion::set_w(double value) {
  set_has_w();
  w_ = value;
}

// -------------------------------------------------------------------

// Role

// optional string id = 10;
inline bool Role::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Role::id() const {
  return *id_;
}
inline void Role::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Role::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Role::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Role::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes name = 1;
inline bool Role::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Role::name() const {
  return *name_;
}
inline void Role::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Role::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Role::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Role::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes perfab_name = 2;
inline bool Role::has_perfab_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Role::set_has_perfab_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Role::clear_has_perfab_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Role::clear_perfab_name() {
  if (perfab_name_ != &::google::protobuf::internal::kEmptyString) {
    perfab_name_->clear();
  }
  clear_has_perfab_name();
}
inline const ::std::string& Role::perfab_name() const {
  return *perfab_name_;
}
inline void Role::set_perfab_name(const ::std::string& value) {
  set_has_perfab_name();
  if (perfab_name_ == &::google::protobuf::internal::kEmptyString) {
    perfab_name_ = new ::std::string;
  }
  perfab_name_->assign(value);
}
inline void Role::set_perfab_name(const char* value) {
  set_has_perfab_name();
  if (perfab_name_ == &::google::protobuf::internal::kEmptyString) {
    perfab_name_ = new ::std::string;
  }
  perfab_name_->assign(value);
}
inline void Role::set_perfab_name(const void* value, size_t size) {
  set_has_perfab_name();
  if (perfab_name_ == &::google::protobuf::internal::kEmptyString) {
    perfab_name_ = new ::std::string;
  }
  perfab_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role::mutable_perfab_name() {
  set_has_perfab_name();
  if (perfab_name_ == &::google::protobuf::internal::kEmptyString) {
    perfab_name_ = new ::std::string;
  }
  return perfab_name_;
}
inline ::std::string* Role::release_perfab_name() {
  clear_has_perfab_name();
  if (perfab_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = perfab_name_;
    perfab_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role::set_allocated_perfab_name(::std::string* perfab_name) {
  if (perfab_name_ != &::google::protobuf::internal::kEmptyString) {
    delete perfab_name_;
  }
  if (perfab_name) {
    set_has_perfab_name();
    perfab_name_ = perfab_name;
  } else {
    clear_has_perfab_name();
    perfab_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .vrmsg.Vector3 position = 3;
inline bool Role::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Role::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Role::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Role::clear_position() {
  if (position_ != NULL) position_->::vrmsg::Vector3::Clear();
  clear_has_position();
}
inline const ::vrmsg::Vector3& Role::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::vrmsg::Vector3* Role::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::vrmsg::Vector3;
  return position_;
}
inline ::vrmsg::Vector3* Role::release_position() {
  clear_has_position();
  ::vrmsg::Vector3* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Role::set_allocated_position(::vrmsg::Vector3* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// optional .vrmsg.Vector3 rotation = 4;
inline bool Role::has_rotation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Role::set_has_rotation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Role::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Role::clear_rotation() {
  if (rotation_ != NULL) rotation_->::vrmsg::Vector3::Clear();
  clear_has_rotation();
}
inline const ::vrmsg::Vector3& Role::rotation() const {
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
}
inline ::vrmsg::Vector3* Role::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) rotation_ = new ::vrmsg::Vector3;
  return rotation_;
}
inline ::vrmsg::Vector3* Role::release_rotation() {
  clear_has_rotation();
  ::vrmsg::Vector3* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void Role::set_allocated_rotation(::vrmsg::Vector3* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
}

// optional .vrmsg.Vector3 scale = 5;
inline bool Role::has_scale() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Role::set_has_scale() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Role::clear_has_scale() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Role::clear_scale() {
  if (scale_ != NULL) scale_->::vrmsg::Vector3::Clear();
  clear_has_scale();
}
inline const ::vrmsg::Vector3& Role::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::vrmsg::Vector3* Role::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::vrmsg::Vector3;
  return scale_;
}
inline ::vrmsg::Vector3* Role::release_scale() {
  clear_has_scale();
  ::vrmsg::Vector3* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void Role::set_allocated_scale(::vrmsg::Vector3* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
}

// optional string groupID = 6;
inline bool Role::has_groupid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Role::set_has_groupid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Role::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Role::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& Role::groupid() const {
  return *groupid_;
}
inline void Role::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void Role::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void Role::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* Role::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes tag_name = 7;
inline bool Role::has_tag_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Role::set_has_tag_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Role::clear_has_tag_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Role::clear_tag_name() {
  if (tag_name_ != &::google::protobuf::internal::kEmptyString) {
    tag_name_->clear();
  }
  clear_has_tag_name();
}
inline const ::std::string& Role::tag_name() const {
  return *tag_name_;
}
inline void Role::set_tag_name(const ::std::string& value) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::kEmptyString) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
}
inline void Role::set_tag_name(const char* value) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::kEmptyString) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
}
inline void Role::set_tag_name(const void* value, size_t size) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::kEmptyString) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role::mutable_tag_name() {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::kEmptyString) {
    tag_name_ = new ::std::string;
  }
  return tag_name_;
}
inline ::std::string* Role::release_tag_name() {
  clear_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_name_;
    tag_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role::set_allocated_tag_name(::std::string* tag_name) {
  if (tag_name_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_name_;
  }
  if (tag_name) {
    set_has_tag_name();
    tag_name_ = tag_name;
  } else {
    clear_has_tag_name();
    tag_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 layer = 8;
inline bool Role::has_layer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Role::set_has_layer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Role::clear_has_layer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Role::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 Role::layer() const {
  return layer_;
}
inline void Role::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
}

// optional bool isNPC = 9;
inline bool Role::has_isnpc() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Role::set_has_isnpc() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Role::clear_has_isnpc() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Role::clear_isnpc() {
  isnpc_ = false;
  clear_has_isnpc();
}
inline bool Role::isnpc() const {
  return isnpc_;
}
inline void Role::set_isnpc(bool value) {
  set_has_isnpc();
  isnpc_ = value;
}

// -------------------------------------------------------------------

// RoleGroup

// optional string id = 1;
inline bool RoleGroup::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleGroup::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleGroup::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleGroup::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& RoleGroup::id() const {
  return *id_;
}
inline void RoleGroup::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RoleGroup::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RoleGroup::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleGroup::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* RoleGroup::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleGroup::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes name = 2;
inline bool RoleGroup::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleGroup::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleGroup::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleGroup::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RoleGroup::name() const {
  return *name_;
}
inline void RoleGroup::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoleGroup::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoleGroup::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleGroup::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RoleGroup::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleGroup::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string creater_id = 3;
inline bool RoleGroup::has_creater_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleGroup::set_has_creater_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleGroup::clear_has_creater_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleGroup::clear_creater_id() {
  if (creater_id_ != &::google::protobuf::internal::kEmptyString) {
    creater_id_->clear();
  }
  clear_has_creater_id();
}
inline const ::std::string& RoleGroup::creater_id() const {
  return *creater_id_;
}
inline void RoleGroup::set_creater_id(const ::std::string& value) {
  set_has_creater_id();
  if (creater_id_ == &::google::protobuf::internal::kEmptyString) {
    creater_id_ = new ::std::string;
  }
  creater_id_->assign(value);
}
inline void RoleGroup::set_creater_id(const char* value) {
  set_has_creater_id();
  if (creater_id_ == &::google::protobuf::internal::kEmptyString) {
    creater_id_ = new ::std::string;
  }
  creater_id_->assign(value);
}
inline void RoleGroup::set_creater_id(const char* value, size_t size) {
  set_has_creater_id();
  if (creater_id_ == &::google::protobuf::internal::kEmptyString) {
    creater_id_ = new ::std::string;
  }
  creater_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleGroup::mutable_creater_id() {
  set_has_creater_id();
  if (creater_id_ == &::google::protobuf::internal::kEmptyString) {
    creater_id_ = new ::std::string;
  }
  return creater_id_;
}
inline ::std::string* RoleGroup::release_creater_id() {
  clear_has_creater_id();
  if (creater_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creater_id_;
    creater_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleGroup::set_allocated_creater_id(::std::string* creater_id) {
  if (creater_id_ != &::google::protobuf::internal::kEmptyString) {
    delete creater_id_;
  }
  if (creater_id) {
    set_has_creater_id();
    creater_id_ = creater_id;
  } else {
    clear_has_creater_id();
    creater_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string create_time = 4;
inline bool RoleGroup::has_create_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoleGroup::set_has_create_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoleGroup::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoleGroup::clear_create_time() {
  if (create_time_ != &::google::protobuf::internal::kEmptyString) {
    create_time_->clear();
  }
  clear_has_create_time();
}
inline const ::std::string& RoleGroup::create_time() const {
  return *create_time_;
}
inline void RoleGroup::set_create_time(const ::std::string& value) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(value);
}
inline void RoleGroup::set_create_time(const char* value) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(value);
}
inline void RoleGroup::set_create_time(const char* value, size_t size) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleGroup::mutable_create_time() {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  return create_time_;
}
inline ::std::string* RoleGroup::release_create_time() {
  clear_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = create_time_;
    create_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleGroup::set_allocated_create_time(::std::string* create_time) {
  if (create_time_ != &::google::protobuf::internal::kEmptyString) {
    delete create_time_;
  }
  if (create_time) {
    set_has_create_time();
    create_time_ = create_time;
  } else {
    clear_has_create_time();
    create_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes description = 5;
inline bool RoleGroup::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoleGroup::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoleGroup::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoleGroup::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& RoleGroup::description() const {
  return *description_;
}
inline void RoleGroup::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void RoleGroup::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void RoleGroup::set_description(const void* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleGroup::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* RoleGroup::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleGroup::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string color = 6;
inline bool RoleGroup::has_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoleGroup::set_has_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoleGroup::clear_has_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoleGroup::clear_color() {
  if (color_ != &::google::protobuf::internal::kEmptyString) {
    color_->clear();
  }
  clear_has_color();
}
inline const ::std::string& RoleGroup::color() const {
  return *color_;
}
inline void RoleGroup::set_color(const ::std::string& value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  color_->assign(value);
}
inline void RoleGroup::set_color(const char* value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  color_->assign(value);
}
inline void RoleGroup::set_color(const char* value, size_t size) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  color_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleGroup::mutable_color() {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  return color_;
}
inline ::std::string* RoleGroup::release_color() {
  clear_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = color_;
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleGroup::set_allocated_color(::std::string* color) {
  if (color_ != &::google::protobuf::internal::kEmptyString) {
    delete color_;
  }
  if (color) {
    set_has_color();
    color_ = color;
  } else {
    clear_has_color();
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WifiSignal

// optional string id = 1;
inline bool WifiSignal::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WifiSignal::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WifiSignal::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WifiSignal::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& WifiSignal::id() const {
  return *id_;
}
inline void WifiSignal::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void WifiSignal::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void WifiSignal::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiSignal::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* WifiSignal::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WifiSignal::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 intensity = 2;
inline bool WifiSignal::has_intensity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WifiSignal::set_has_intensity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WifiSignal::clear_has_intensity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WifiSignal::clear_intensity() {
  intensity_ = 0;
  clear_has_intensity();
}
inline ::google::protobuf::int32 WifiSignal::intensity() const {
  return intensity_;
}
inline void WifiSignal::set_intensity(::google::protobuf::int32 value) {
  set_has_intensity();
  intensity_ = value;
}

// optional .vrmsg.Vector3 myPos = 3;
inline bool WifiSignal::has_mypos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WifiSignal::set_has_mypos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WifiSignal::clear_has_mypos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WifiSignal::clear_mypos() {
  if (mypos_ != NULL) mypos_->::vrmsg::Vector3::Clear();
  clear_has_mypos();
}
inline const ::vrmsg::Vector3& WifiSignal::mypos() const {
  return mypos_ != NULL ? *mypos_ : *default_instance_->mypos_;
}
inline ::vrmsg::Vector3* WifiSignal::mutable_mypos() {
  set_has_mypos();
  if (mypos_ == NULL) mypos_ = new ::vrmsg::Vector3;
  return mypos_;
}
inline ::vrmsg::Vector3* WifiSignal::release_mypos() {
  clear_has_mypos();
  ::vrmsg::Vector3* temp = mypos_;
  mypos_ = NULL;
  return temp;
}
inline void WifiSignal::set_allocated_mypos(::vrmsg::Vector3* mypos) {
  delete mypos_;
  mypos_ = mypos;
  if (mypos) {
    set_has_mypos();
  } else {
    clear_has_mypos();
  }
}

// optional string device = 4;
inline bool WifiSignal::has_device() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WifiSignal::set_has_device() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WifiSignal::clear_has_device() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WifiSignal::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& WifiSignal::device() const {
  return *device_;
}
inline void WifiSignal::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void WifiSignal::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void WifiSignal::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiSignal::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* WifiSignal::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WifiSignal::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 5;
inline bool WifiSignal::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WifiSignal::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WifiSignal::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WifiSignal::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& WifiSignal::name() const {
  return *name_;
}
inline void WifiSignal::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WifiSignal::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WifiSignal::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiSignal::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* WifiSignal::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WifiSignal::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nowtime = 6;
inline bool WifiSignal::has_nowtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WifiSignal::set_has_nowtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WifiSignal::clear_has_nowtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WifiSignal::clear_nowtime() {
  if (nowtime_ != &::google::protobuf::internal::kEmptyString) {
    nowtime_->clear();
  }
  clear_has_nowtime();
}
inline const ::std::string& WifiSignal::nowtime() const {
  return *nowtime_;
}
inline void WifiSignal::set_nowtime(const ::std::string& value) {
  set_has_nowtime();
  if (nowtime_ == &::google::protobuf::internal::kEmptyString) {
    nowtime_ = new ::std::string;
  }
  nowtime_->assign(value);
}
inline void WifiSignal::set_nowtime(const char* value) {
  set_has_nowtime();
  if (nowtime_ == &::google::protobuf::internal::kEmptyString) {
    nowtime_ = new ::std::string;
  }
  nowtime_->assign(value);
}
inline void WifiSignal::set_nowtime(const char* value, size_t size) {
  set_has_nowtime();
  if (nowtime_ == &::google::protobuf::internal::kEmptyString) {
    nowtime_ = new ::std::string;
  }
  nowtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiSignal::mutable_nowtime() {
  set_has_nowtime();
  if (nowtime_ == &::google::protobuf::internal::kEmptyString) {
    nowtime_ = new ::std::string;
  }
  return nowtime_;
}
inline ::std::string* WifiSignal::release_nowtime() {
  clear_has_nowtime();
  if (nowtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nowtime_;
    nowtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WifiSignal::set_allocated_nowtime(::std::string* nowtime) {
  if (nowtime_ != &::google::protobuf::internal::kEmptyString) {
    delete nowtime_;
  }
  if (nowtime) {
    set_has_nowtime();
    nowtime_ = nowtime;
  } else {
    clear_has_nowtime();
    nowtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vrmsg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_WifiMessage_2eproto__INCLUDED
